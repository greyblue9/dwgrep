<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Syntax &mdash; dwgrep 0.2 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="dwgrep 0.2 documentation" href="index.html" />
    <link rel="up" title="Table of contents" href="fulltoc.html" />
    <link rel="next" title="Core vocabulary" href="vocabulary-core.html" />
    <link rel="prev" title="Assorted examples" href="examples.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="vocabulary-core.html" title="Core vocabulary"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="examples.html" title="Assorted examples"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">dwgrep 0.2 documentation</a> &raquo;</li>
          <li><a href="fulltoc.html" accesskey="U">Table of contents</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="syntax">
<span id="id1"></span><h1>Syntax<a class="headerlink" href="#syntax" title="Permalink to this headline">¶</a></h1>
<p>This section describes all syntactic constructs in Zwerg language.
You may want to check out <a class="reference internal" href="tutorial.html#tutorial"><em>Tutorial</em></a>, which introduces many (but
not all) of these concepts on an example, and
<a class="reference internal" href="vocabulary-core.html#zw-vocabulary-core"><em>Core vocabulary</em></a> or <a class="reference internal" href="vocabulary-dwarf.html#zw-vocabulary-dwarf"><em>Dwarf vocabulary</em></a> to learn about
the actual function words that you can use.</p>
<div class="section" id="comments">
<h2>Comments<a class="headerlink" href="#comments" title="Permalink to this headline">¶</a></h2>
<p>Form:</p>
<div class="highlight-python"><div class="highlight"><pre>// Ignored until the end of the line.
# This one as well.
/* C-like comments work as well.  */
</pre></div>
</div>
<p>Comments are ignored.  Nesting comments is not allowed.</p>
</div>
<div class="section" id="empty-expression">
<h2>Empty expression<a class="headerlink" href="#empty-expression" title="Permalink to this headline">¶</a></h2>
<p>Empty expression yields exactly the stacks that get to its input.</p>
<p>For example, the following is an empty expression within negative
sub-expression assertion.  This expression never yields anything:</p>
<div class="highlight-python"><div class="highlight"><pre>!()     # An expression that never yields.
</pre></div>
</div>
<p>As another example, it may be useful to bind the initial Dwarf value
to a name, typically in cases when one needs to refer to it several
times.  One way to do this is this:</p>
<div class="highlight-python"><div class="highlight"><pre>let Dw := ;     # There&#39;s an empty expression between := and ;.
</pre></div>
</div>
</div>
<div class="section" id="words">
<h2>Words<a class="headerlink" href="#words" title="Permalink to this headline">¶</a></h2>
<p>Form:</p>
<div class="highlight-python"><div class="highlight"><pre>foo
?foo
!foo
@foo    # and more.
</pre></div>
</div>
<p>Most functional parts of Zwerg expressions are expressed by words.
Words consume input stacks and may yield possibly several stacks of
arbitrary composition.  A typical word would inspect or pop one or
more words on each incoming stack, carry out some computation, and
produce zero or more stacks with the results of computation pushed to
them.</p>
<p>For example, the word <tt class="docutils literal"><span class="pre">entry</span></tt> expects a stack with a Dwarf value on
top.  It then examines the Dwarf data, and for each debug info entry
(DIE), it produces a stack with that DIE pushed on top (instead of the
consumed Dwarf value).  E.g.:</p>
<div class="highlight-python"><div class="highlight"><pre>$ dwgrep ./tests/nontrivial-types.o -e &#39;&#39;
&lt;Dwarf &quot;./tests/nontrivial-types.o&quot;&gt;

$ dwgrep ./tests/nontrivial-types.o -e &#39;entry&#39;
[b]     compile_unit
        producer (strp) GNU C 4.6.3 20120306 (Red Hat 4.6.3-2);
        [... more attributes ...]
[2d]    structure_type
        name (string)   foo;
        [... more attributes ...]
[35]    subprogram
        external (flag) true;
        name (strp)     blah;
        [... more attributes ...]
[... more output ...]
</pre></div>
</div>
<p>Some words (actually quite a few of them) will change their behavior
depending on what values are on the stack.  E.g. <tt class="docutils literal"><span class="pre">entry</span></tt> is besides
Dwarfs applicable to, as of this writing, compilation units and
abbreviation units.</p>
<p>The words that start with <tt class="docutils literal"><span class="pre">?</span></tt> and <tt class="docutils literal"><span class="pre">!</span></tt> are assertions.  While what
was written about words in general applies to assertions as well,
their mode of operation is more restricted.  Assertions either yield
the incoming stack unchanged, or yield nothing at all.</p>
<p>The assertions come in pairs, where the <tt class="docutils literal"><span class="pre">?</span></tt>-flavored one tests the
positive condition (e.g. <tt class="docutils literal"><span class="pre">?root</span></tt> tests whether a DIE on top of stack
is a root DIE), and the <tt class="docutils literal"><span class="pre">!</span></tt>-flavored one tests the opposite
condition (e.g. <tt class="docutils literal"><span class="pre">!root</span></tt> tests whether a DIE on top of stack is not a
root DIE).</p>
</div>
<div class="section" id="concatenation">
<h2>Concatenation<a class="headerlink" href="#concatenation" title="Permalink to this headline">¶</a></h2>
<p>Form:</p>
<div class="highlight-python"><div class="highlight"><pre>EXPR₁ EXPR₂ …
</pre></div>
</div>
<p>The resulting expression passes all input stacks to <em>EXPR₁</em>, takes the
output of that, passes it to <em>EXPR₂</em>, and so on.  The result of
concatenation is then whatever the last constituent expression yields.</p>
<p>The constituent expressions are evaluated in plain context.</p>
</div>
<div class="section" id="parenthesizing">
<h2>Parenthesizing<a class="headerlink" href="#parenthesizing" title="Permalink to this headline">¶</a></h2>
<p>Form:</p>
<div class="highlight-python"><div class="highlight"><pre>(EXPR₁)
</pre></div>
</div>
<p>Concatenation has a high precedence, so parentheses can be used
liberally to adjust how an expression should be chopped into
sub-expression.  The parenthesized expression is evaluated in plain
context.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>foo bar, baz    # these two ...
(foo bar), baz  # ... mean the same thing
foo (bar, baz)  # this one is different
</pre></div>
</div>
</div>
<div class="section" id="integer-literals">
<h2>Integer literals<a class="headerlink" href="#integer-literals" title="Permalink to this headline">¶</a></h2>
<p>Form:</p>
<div class="highlight-python"><div class="highlight"><pre>“-”?(“0x”|“0o”|“0b”|“0”|“”){digits}
</pre></div>
</div>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">0x</span></tt> and <tt class="docutils literal"><span class="pre">0X</span></tt> are hexadecimal prefixes.  Valid digits are
<tt class="docutils literal"><span class="pre">[0-9a-fA-F]</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">0o</span></tt>, <tt class="docutils literal"><span class="pre">0O</span></tt> and <tt class="docutils literal"><span class="pre">0</span></tt> are octal prefixes.  Valid digits are
<tt class="docutils literal"><span class="pre">[0-7]</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">0b</span></tt> and <tt class="docutils literal"><span class="pre">0B</span></tt> are binary prefixes.  Valid digits are <tt class="docutils literal"><span class="pre">[0-1]</span></tt>.</li>
<li>Without prefix, decimal base is assumed.  Valid digits are
<tt class="docutils literal"><span class="pre">[0-9]</span></tt>.</li>
<li>An initial <tt class="docutils literal"><span class="pre">-</span></tt> means the number is negative.</li>
</ul>
<p>Zwerg integers can hold any 64-bit signed or unsigned number:</p>
<div class="highlight-python"><div class="highlight"><pre>$ dwgrep &#39;0xffffffffffffffff -0x7fffffffffffffff add&#39;
0x8000000000000000
</pre></div>
</div>
</div>
<div class="section" id="named-constants">
<h2>Named constants<a class="headerlink" href="#named-constants" title="Permalink to this headline">¶</a></h2>
<p>Form:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">DW_AT_name</span>
<span class="n">DW_TAG_base_type</span>
<span class="n">DW_FORM_strp</span>
<span class="n">DW_LANG_C</span>
</pre></div>
</div>
<p>Zwerg has support for named constants.  They aren&#8217;t merely aliases for
numbers&#8211;Zwerg remembers their domain and uses it when the value needs
to be displayed or converted to a string.  It is still possible to
extract the underlying numerical value:</p>
<div class="highlight-python"><div class="highlight"><pre>$ dwgrep &#39;DW_TAG_base_type value&#39;
36
$ dwgrep &#39;DW_TAG_base_type hex&#39;
0x24
</pre></div>
</div>
<p>Numbers in non-decimal bases use the same trick, so if you use a
hexadecimal number, it will keep its hexadecimal-ness throughout the
script:</p>
<div class="highlight-python"><div class="highlight"><pre>$ dwgrep &#39;10 0x10 0o10 0b10&#39;
---
0b10
010
0x10
10
</pre></div>
</div>
<p>Similarly values decoded from attribute will have the
appropriate &#8220;skin&#8221;&#8211;they will be named constants, hexadecimal or
decimal numbers, depending on what is deemed the best fit:</p>
<div class="highlight-python"><div class="highlight"><pre>$ dwgrep ... -e &#39;entry @AT_language&#39;
DW_LANG_C89

$ dwgrep ... -e &#39;entry @AT_decl_line&#39;
4
6
11

$ dwgrep ... -e &#39;entry @AT_low_pc&#39;
0x80483f0
0x80482f0
</pre></div>
</div>
</div>
<div class="section" id="lexical-scopes-a">
<h2>Lexical scopes (<tt class="docutils literal"><span class="pre">(|A|…)</span></tt>)<a class="headerlink" href="#lexical-scopes-a" title="Permalink to this headline">¶</a></h2>
<p>Form:</p>
<div class="highlight-python"><div class="highlight"><pre>(|ID₁ ID₂ …| EXPR₁)
</pre></div>
</div>
<p>A presence of binding block in a parenthesized construct converts the
whole form into a function that pops as many arguments as there are
identifiers in the binding block, and binds them to these identifiers
such that the rightmost one gets the value on TOS and then
progressively lefter <em>ID</em>&#8216;s get progressively deeper stack values.
The expression is then evaluated as usual, except one can use the
bound names.</p>
<p>Sometimes it&#8217;s useful to enclose the whole expression into a scope and
pop and bound the initial Dwarf value:</p>
<div class="highlight-python"><div class="highlight"><pre>(|Dw| Dw entry (name == Dw symtab name))
</pre></div>
</div>
<p>Another example shows how to implement set union even without
first-class Zwerg support:</p>
<div class="highlight-python"><div class="highlight"><pre>[foo] [bar] (|A B| A [B elem !(== A elem)] add)
</pre></div>
</div>
</div>
<div class="section" id="alt-lists">
<h2>ALT-lists (<tt class="docutils literal"><span class="pre">,</span></tt>)<a class="headerlink" href="#alt-lists" title="Permalink to this headline">¶</a></h2>
<p>Form:</p>
<div class="highlight-python"><div class="highlight"><pre>EXPR₁ “,” EXPR₂ …
</pre></div>
</div>
<p>The resulting expression passes all input stacks to all of <em>EXPR₁</em>,
<em>EXPR₂</em>, etc.  It then yields any and all stacks that any of the
constituent expressions yields.</p>
<p>All constituent expressions shall have the same overall stack effect
(the number of slots pushed minus number of slots popped will be the
same for each branch).</p>
<p>The constituent expressions are evaluated in plain context.</p>
<p>E.g. to compare a TOS value to one of the fixed list of values, you
would do:</p>
<div class="highlight-python"><div class="highlight"><pre>(== (1, 2, 3))
</pre></div>
</div>
<p>You would also use ALT-lists to create a sequence value:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="or-lists">
<h2>OR-lists (<tt class="docutils literal"><span class="pre">||</span></tt>)<a class="headerlink" href="#or-lists" title="Permalink to this headline">¶</a></h2>
<p>Form:</p>
<div class="highlight-python"><div class="highlight"><pre>EXPR₁ “||” EXPR₂ …
</pre></div>
</div>
<p>Each input stack is passed first to <em>EXPR₁</em>.  If that yields anything,
that&#8217;s what the overall expression yields.  Otherwise the same
original input stack is passed to <em>EXPR₂</em>, and so in this fashion.  If
neither constituent expression yields anything, the overall expression
doesn&#8217;t yield anything either.  The mode of operation is very similar
to shell-like OR lists, hence the name.</p>
<p>All constituent expressions shall have the same overall stack effect
(the number of slots pushed minus number of slots popped will be the
same for each branch).</p>
<p>The constituent expressions are evaluated in plain context.</p>
<p>An important use of an OR list is to implement case-like conditions
and fallback cases:</p>
<div class="highlight-python"><div class="highlight"><pre>let name := (@DW_AT_linkage_name || @DW_AT_MIPS_linkage_name
             || @DW_AT_name || &quot;???&quot;);

let has_loc := (?(@DW_AT_location) true || false);
</pre></div>
</div>
</div>
<div class="section" id="infix-assertions">
<h2>Infix assertions (<tt class="docutils literal"><span class="pre">==</span></tt>)<a class="headerlink" href="#infix-assertions" title="Permalink to this headline">¶</a></h2>
<p>Form:</p>
<div class="highlight-python"><div class="highlight"><pre>EXPR₁ OP₁ EXPR₂
</pre></div>
</div>
<p>Zwerg has support for infix binary assertions.  These forms are
evaluated as follows:</p>
<div class="highlight-python"><div class="highlight"><pre>?(let .tmp1 := EXPR₁; let .tmp2 := EXPR₂; .tmp1 .tmp2 OP₂)
</pre></div>
</div>
<p>In plain English, <em>EXPR₁</em> and <em>EXPR₂</em> are each evaluated in
sub-expression context.  The TOS&#8217;s of the stacks that this produces
are then put to stack and a certain operator is evaluated.  This shows
that the two expressions are independent of each other.</p>
<p>What actual word <em>OP₂</em> refers to depends on what operator OP₁ is, but
it will be an assertion that looks at top two stack slots.  There
might be no actual word per se, but conceptually this is how the form
behaves.</p>
<p>Another thing worth noticing is that the whole form behaves as an
assertion.  No side effects leak from the constituent <em>EXPR</em>&#8216;s or from
the operator itself.</p>
<p>Individual operators are essentially just words, just with a bit of
syntactical support on Zwerg side.  So which operators are available
depends on which vocabularies any particular wrapper brings in.  Zwerg
core defines the following <em>OP₁</em>&#8216;s with the following associated
<em>OP₂</em>&#8216;s:</p>
<div class="highlight-python"><div class="highlight"><pre>EXPR₁ “==” EXPR₂        # ?eq
EXPR₁ “!=” EXPR₂        # ?ne
EXPR₁ “&lt;” EXPR₂         # ?lt
EXPR₁ “&lt;=” EXPR₂        # ?le
EXPR₁ “&gt;” EXPR₂         # ?gt
EXPR₁ “&gt;=” EXPR₂        # ?ge
EXPR₁ “=~” EXPR₂        # ?match
EXPR₁ “!~” EXPR₂        # !match
</pre></div>
</div>
<p>See <a class="reference internal" href="vocabulary-core.html#id9"><em>?eq</em></a> to learn about comparison
operators.  See <a class="reference internal" href="vocabulary-core.html#id23"><em>?match</em></a> to learn
about regular expression matching.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>$ dwgrep ./tests/typedef.o -e &#39;entry (offset == 0x1d)&#39;
[1d]    typedef
        name (strp)     int_t;
        decl_file (data1)       /home/petr/proj/dwgrep/typedef.c;
        decl_line (data1)       1;
        type (ref4)     [28];
</pre></div>
</div>
</div>
<div class="section" id="iteration">
<h2>Iteration (<tt class="docutils literal"><span class="pre">*</span></tt>)<a class="headerlink" href="#iteration" title="Permalink to this headline">¶</a></h2>
<p>Form:</p>
<div class="highlight-python"><div class="highlight"><pre>EXPR₁ “*”
EXPR₁ “+”
EXPR₁ “?”
</pre></div>
</div>
<p>The effect of expressions <tt class="docutils literal"><span class="pre">EXPR₁*</span></tt> is that the input stack is
yielded unchanged, and also passed to <em>EXPR₁</em>.  The output is
collected and yielded, and then passed back to <em>EXPR₁</em>.  This process
is repeated until <em>EXPR₁</em> stops yielding more stacks.</p>
<p>This is typically used for forming closures&#8211;peeling uninteresting
types, forming sets of nodes, etc.  E.g.:</p>
<div class="highlight-python"><div class="highlight"><pre>child*  # nodes of tree rooted in node that&#39;s on TOS
</pre></div>
</div>
<p>One can also (ab)use this to create an explicit for loop:</p>
<div class="highlight-python"><div class="highlight"><pre>0 (1 add ?(10 ?lt))*
</pre></div>
</div>
<p><em>EXPR₁</em> shall push exactly the same number of stack slots as it pops.</p>
<p>The effect of <tt class="docutils literal"><span class="pre">EXPR₁+</span></tt> is the same as that of <tt class="docutils literal"><span class="pre">EXPR₁</span> <span class="pre">EXPR₁*</span></tt>.</p>
<p>The effect of <tt class="docutils literal"><span class="pre">EXPR₁?</span></tt> is the same as that of <tt class="docutils literal"><span class="pre">(,</span> <span class="pre">EXPR₁)</span></tt>.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre>A B swap? ?gt drop    # &quot;max&quot; -- keep the greater number on stack
A B swap? ?lt drop    # &quot;min&quot;
</pre></div>
</div>
</div>
<div class="section" id="formatting-strings">
<h2>Formatting strings<a class="headerlink" href="#formatting-strings" title="Permalink to this headline">¶</a></h2>
<p>Form:</p>
<div class="highlight-python"><div class="highlight"><pre>“r”? “&quot;” (formatting string) “&quot;” “\”?
</pre></div>
</div>
<p>Zwerg string literals are functions that push themselves to an
incoming stack, which they then yield.  The literal is enclosed in
quotes and if a quote itself should be part of the string, it should
be escaped with a backslash (<tt class="docutils literal"><span class="pre">\</span></tt>).  Should a backslash be part of
the string and not considered an escape character, it should be
escaped by another backslash:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="s">&quot;a simple string&quot;</span>
<span class="s">&quot;a string </span><span class="se">\&quot;</span><span class="s">with</span><span class="se">\&quot;</span><span class="s"> quotes&quot;</span>
<span class="s">&quot;a string with backslash: </span><span class="se">\\</span><span class="s">&quot;</span>
</pre></div>
</div>
<p>Other recognized escapes include:</p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="84%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">escape</th>
<th class="head">meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">\\</span></tt></td>
<td><p class="first">Escaped backslash stands for a backslash:</p>
<div class="last highlight-python"><div class="highlight"><pre>$ dwgrep &#39;&quot;\\a\\&quot;&#39;
\a\
</pre></div>
</div>
</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">\123</span></tt></td>
<td><p class="first"><em>123</em> stands for octal number.  The escape is replaced
with an ASCII character the code of which is the octal
number:</p>
<div class="last highlight-python"><div class="highlight"><pre>$ dwgrep &#39;&quot;\110\145\154\154\157&quot;&#39;
Hello
</pre></div>
</div>
</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">\xab</span></tt></td>
<td><p class="first"><em>ab</em> stands for hexadecimal number.  The meaning is
analogous to that of \123:</p>
<div class="last highlight-python"><div class="highlight"><pre>$ dwgrep &#39;&quot;\x77\x6f\x72\x6c\x64\x21&quot;&#39;
world!
</pre></div>
</div>
</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">\t</span></tt></td>
<td>Stands for the tab character.</td>
</tr>
<tr class="row-even"><td><p class="first"><tt class="docutils literal"><span class="pre">\n</span></tt></p>
<p class="last"><tt class="docutils literal"><span class="pre">&lt;EOL&gt;</span></tt></p>
</td>
<td><p class="first">Both a literal end-of-line character, as well as the
<tt class="docutils literal"><span class="pre">\n</span></tt> escape stand for new line:</p>
<div class="last highlight-python"><div class="highlight"><pre>$ dwgrep &#39;&quot;foo\nbar&quot;&#39;
foo
bar

$ dwgrep &#39;&quot;foo
bar&quot;&#39;
foo
bar
</pre></div>
</div>
</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">\&lt;EOL&gt;</span></tt></td>
<td><p class="first">Escaped newline is ignored:</p>
<div class="last highlight-python"><div class="highlight"><pre>$ dwgrep &#39;&quot;foo\
bar&quot;&#39;
foobar
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
<p>There are more escape sequences (essentially those mentioned in <tt class="docutils literal"><span class="pre">man</span>
<span class="pre">ascii</span></tt> are supported as well).</p>
<p>If a string literal is prefixed by <tt class="docutils literal"><span class="pre">r</span></tt>, it&#8217;s actually a raw string
literal.  These work the same as normal formatting strings, but escape
sequences are left intact in the string:</p>
<div class="highlight-python"><div class="highlight"><pre>$ dwgrep &#39;&quot;foo \&quot;bar\\\&quot;&quot;&#39;
foo &quot;bar\&quot;

$ dwgrep &#39;r&quot;foo \&quot;bar\\\&quot;&quot;&#39;
foo \&quot;bar\\\&quot;
</pre></div>
</div>
<p>String literals can be split, provided that all but the last segment
end not with a mere quote, but <tt class="docutils literal"><span class="pre">&quot;\</span></tt>.  The following two examples
produce equivalent programs:</p>
<div class="highlight-python"><div class="highlight"><pre>&quot;a long string &quot;\ &quot;that continues here&quot;
&quot;a long string that continues here&quot;
</pre></div>
</div>
<p>Any whitespace (but only whitespace) is allowed between <tt class="docutils literal"><span class="pre">&quot;\</span></tt> and the
following <tt class="docutils literal"><span class="pre">&quot;</span></tt>.</p>
<p>String literals can contain formatting directives.  Formatting
directive are two-character sequences whose first character is a
<tt class="docutils literal"><span class="pre">%</span></tt>.  Such strings are not merely literals anymore, they behave more
as template strings.  They are functions that take values from the
stack and splice their string representation together with the
non-formatting-directive parts of the string.</p>
<p>A pseudo-directive <tt class="docutils literal"><span class="pre">%%</span></tt> is not really a directive at all, it&#8217;s an
escape that stands for a single percent character.</p>
<p>The simplest formatting directive is <tt class="docutils literal"><span class="pre">%s</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre>$ dwgrep ... -e &#39;entry ?AT_decl_column !AT_decl_line
                 &quot;%s has DW_AT_decl_column, but NOT DW_AT_decl_line&quot;&#39;
[58] formal_parameter has DW_AT_decl_column, but NOT DW_AT_decl_line

$ dwgrep ... -e &#39;entry attribute (form &quot;%s&quot; =~ &quot;DW_FORM_ref.*&quot;)&#39;
type (ref4)     [65];
sibling (ref4)  [65];
type (ref4)     [2d];
[... etc ...]
</pre></div>
</div>
<p>The most general formatting directive is a pair of <tt class="docutils literal"><span class="pre">%(</span></tt> and <tt class="docutils literal"><span class="pre">%)</span></tt>,
which encloses an expression.  The formatting string passes input
stacks to that expression, which is evaluated in plain context.  TOS
of yielded stacks is then popped, converted to a string, spliced, and
the resulting string is pushed to stack.  For example:</p>
<div class="highlight-python"><div class="highlight"><pre>$ dwgrep ... -f /dev/stdin &lt;&lt;&quot;EOF&quot;
(|Dw|
 let T := Dw entry ?TAG_typedef ;
 let U := T @AT_type (?TAG_typedef @AT_type)* !TAG_typedef ;

 &quot;[%( T offset %)] typedef %( T @AT_name %) %( U @AT_name || &quot;???&quot; %) &quot;\
 &quot;(%( U @AT_encoding || &quot;???&quot; %), %( U @AT_byte_size || &quot;???&quot; %) bytes)&quot;
)
EOF
[0x1d] typedef int_t int (DW_ATE_signed, 4 bytes)
[0x2f] typedef int_t_t int (DW_ATE_signed, 4 bytes)
[0x3a] typedef int_t_t_t int (DW_ATE_signed, 4 bytes)
</pre></div>
</div>
<p>If there&#8217;s more than one formatting directive in a given string, they
are resolved in the order from right to left (sic!): rightmost
formatting directive gets TOS value:</p>
<div class="highlight-python"><div class="highlight"><pre>$ dwgrep &#39;dwgrep &#39;1 2 3 &quot;{%s [%s (%s)]}&quot;&#39;
{1 [2 (3)]}
</pre></div>
</div>
<p>This principle is applied throughout Zwerg: when a binding block
contains several names the rightmost name is bound to value on TOS.
The reason should be apparent from the above example: because the
strings are parsed from left to right, rightmost word produces the
topmost stack value.</p>
<p>Now that we have introduced <tt class="docutils literal"><span class="pre">%(</span> <span class="pre">%)</span></tt>, it is easy to use it to define
the others:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">%s</span></tt> stands for <tt class="docutils literal"><span class="pre">%(</span> <span class="pre">%)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">%d</span></tt> stands for <tt class="docutils literal"><span class="pre">%(</span> <span class="pre">value</span> <span class="pre">%)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">%x</span></tt> stands for <tt class="docutils literal"><span class="pre">%(</span> <span class="pre">value</span> <span class="pre">hex</span> <span class="pre">%)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">%o</span></tt> stands for <tt class="docutils literal"><span class="pre">%(</span> <span class="pre">value</span> <span class="pre">oct</span> <span class="pre">%)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">%b</span></tt> stands for <tt class="docutils literal"><span class="pre">%(</span> <span class="pre">value</span> <span class="pre">bin</span> <span class="pre">%)</span></tt></li>
</ul>
</div>
<div class="section" id="sequence-capture">
<h2>Sequence capture (<tt class="docutils literal"><span class="pre">[]</span></tt>)<a class="headerlink" href="#sequence-capture" title="Permalink to this headline">¶</a></h2>
<p>Form:</p>
<div class="highlight-python"><div class="highlight"><pre>“[” EXPR₁ “]”
</pre></div>
</div>
<p>Sequences offer a way to gather values yielded by another expression.
If you think of ALT-list as a fork, then capture is a join.</p>
<p>The resulting expression passes any input stacks to <em>EXPR₁</em>.  For each
input stack, it gathers the stacks produced by <em>EXPR₁</em>, takes the top
value off each of them, and collects these values in a sequence.  This
sequence it then pushes to TOS.</p>
<p><em>EXPR₁</em> is evaluated in sub-expression context.  That means that the
sequence is pushed to TOS <em>in addition</em> to whatever was already
there&#8211;nothing is removed.</p>
<p>Of particular interest is interplay between ALT-list and capture,
which allows easy and syntactically familiar construction of sequence
literals:</p>
<div class="highlight-python"><div class="highlight"><pre>$ dwgrep &#39;[1, 2, 3]&#39;
[1, 2, 3]
</pre></div>
</div>
<p>Or you can use this construct to e.g. collect children of a node on
TOS:</p>
<div class="highlight-python"><div class="highlight"><pre>$ dwgrep ./tests/typedef.o -e &#39;entry ?root [child]&#39;
---
[[1d] typedef, [28] base_type, [2f] typedef, [3a] typedef, [45] variable]
[b]     compile_unit
        producer (strp) GNU C 4.6.3 20120306 (Red Hat 4.6.3-2);
        language (data1)        DW_LANG_C89;
        name (strp)     typedef.c;
        comp_dir (strp) /home/petr/proj/dwgrep;
        stmt_list (data4)       0;
</pre></div>
</div>
<p>Or the whole tree rooted at node on TOS:</p>
<div class="highlight-python"><div class="highlight"><pre>dwgrep ./tests/typedef.o -e &#39;entry ?root [child*]&#39;
---
[[b] compile_unit, [45] variable, [3a] typedef, [2f] typedef, [28] base_type, [1d] typedef]
[b]     compile_unit
        producer (strp) GNU C 4.6.3 20120306 (Red Hat 4.6.3-2);
        language (data1)        DW_LANG_C89;
        name (strp)     typedef.c;
        comp_dir (strp) /home/petr/proj/dwgrep;
        stmt_list (data4)       0;
</pre></div>
</div>
<p>Form:</p>
<div class="highlight-python"><div class="highlight"><pre>“[” “]”
</pre></div>
</div>
<p>This produces an empty list.  Alternatively, one could also do:</p>
<div class="highlight-python"><div class="highlight"><pre>[!()]
</pre></div>
</div>
<p>But that&#8217;s somewhat awkward.</p>
<p>To capture an empty expression, one would need to explicitly
parenthesize it:</p>
<div class="highlight-python"><div class="highlight"><pre>$ dwgrep &#39;1 [()]&#39;
---
[1]
1
</pre></div>
</div>
</div>
<div class="section" id="capture-with-binding-a">
<h2>Capture with binding (<tt class="docutils literal"><span class="pre">[|A|…]</span></tt>)<a class="headerlink" href="#capture-with-binding-a" title="Permalink to this headline">¶</a></h2>
<p>Form:</p>
<div class="highlight-python"><div class="highlight"><pre>“[” “|” ID₁ ID₂ … “|” EXPR₁ “]”
</pre></div>
</div>
<p>Sub-expression capture allows a binding block.  A presence of such
block converts the whole form into a function that pops as many
arguments as there are identifiers in the binding block, and binds
them to these identifiers such that the rightmost one get the value on
TOS and then progressively lefter <em>ID</em>&#8216;s get progressively deeper
stack values.  The expression is then evaluated as usual, except one
can use the bound names:</p>
<div class="highlight-python"><div class="highlight"><pre>$ dwgrep ./tests/typedef.o -e &#39;entry ?root [|A| A child]&#39;
[[1d] typedef, [28] base_type, [2f] typedef, [3a] typedef, [45] variable]

$ dwgrep &#39;1 [|A| A]&#39;    # or you could just write &#39;[1]&#39; ;)
[1]
</pre></div>
</div>
</div>
<div class="section" id="name-binding-let">
<h2>Name binding (<tt class="docutils literal"><span class="pre">let</span></tt>)<a class="headerlink" href="#name-binding-let" title="Permalink to this headline">¶</a></h2>
<p>Form:</p>
<div class="highlight-python"><div class="highlight"><pre>“let” ID₁ ID₂ … “:=” EXPR₁ “;”
</pre></div>
</div>
<p>This form introduces a new name into the current scope.  It passes the
input stack to <em>EXPR₁</em>, which is evaluated in sub-expression context.
Then values near TOS are bound to given identifiers and exported into
surrounding context.  Then the original stack is yielded as many times
as <em>EXPR₁</em> yields, each time with a possibly different set of
bindings.  Bound names may be mentioned later, and they push the bound
value to the stack.</p>
<p>Consider the following examples:</p>
<div class="highlight-python"><div class="highlight"><pre>$ dwgrep &#39;let X := 1; X&#39;
1

$ dwgrep &#39;let X := 1, 2; X&#39;
1
2
</pre></div>
</div>
<p>Ordering of ID&#8217;s is such that the rightmost is bound to TOS, the next
one to the left to one below TOS, etc.  The mnemonic for this is that
the list of variables describes stack layout, with TOS being on the
right.  E.g.:</p>
<div class="highlight-python"><div class="highlight"><pre>$ dwgrep &#39;let A B := 1 2, 3 4; A B&#39;
---
2
1
---
4
3
</pre></div>
</div>
<p>The new bindings are introduced into the most enclosing scope.  The
following constructs comprise a scope:</p>
<ul>
<li><p class="first">Any sub-expression context has a scope of its own:</p>
<div class="highlight-python"><div class="highlight"><pre>$ dwgrep &#39;?(let A := 1;) A&#39;
Error: Unknown identifier `A&#39;.
</pre></div>
</div>
</li>
<li><p class="first">Each branch of an OR-list or ALT-list has a scope of its own:</p>
<div class="highlight-python"><div class="highlight"><pre>$ dwgrep &#39;(let A := 1;, let A := 2;) A&#39;
Error: Unknown identifier `A&#39;.
</pre></div>
</div>
</li>
<li><p class="first">Parenthesized expressions with name binding blocks are a scope:</p>
<div class="highlight-python"><div class="highlight"><pre>$ dwgrep &#39;&quot;&quot; (|X| let A := 1;) A&#39;
Error: Unknown identifier `A&#39;.
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">then</span></tt> and <tt class="docutils literal"><span class="pre">else</span></tt> branches of an <tt class="docutils literal"><span class="pre">if-then-else</span></tt> form
each introduce a scope:</p>
<div class="highlight-python"><div class="highlight"><pre>$ dwgrep &#39;if ?() then let A := 1; else let A := 2; A&#39;
Error: Unknown identifier `A&#39;.
</pre></div>
</div>
<p>Typically these constructs can be rewritten as follows:</p>
<div class="highlight-python"><div class="highlight"><pre>$ dwgrep &#39;let A := if ?() then 1 else 2; A&#39;
1
</pre></div>
</div>
</li>
</ul>
<p>On the other hand, simple parenthesizing does not introduce a scope:</p>
<div class="highlight-python"><div class="highlight"><pre>$ dwgrep &#39;(let A := 1;) A&#39;
1
</pre></div>
</div>
<p>It is not allowed to rebind an once-bound name within the same scope:</p>
<div class="highlight-python"><div class="highlight"><pre>$ dwgrep &#39;let A := 1; let A := 1;&#39;
Error: Name `A&#39; rebound.
</pre></div>
</div>
<p>It is also not possible to access names from outer scopes if they are
shadowed by the same name in an inner scope.  In the following, the
inner reference to <tt class="docutils literal"><span class="pre">A</span></tt> will always resolve to <tt class="docutils literal"><span class="pre">2</span></tt>, and there is no
way to access the outer <tt class="docutils literal"><span class="pre">A</span></tt> of <tt class="docutils literal"><span class="pre">1</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre>$ dwgrep &#39;let A := 1; 2 [|A| A]&#39;
[2]
</pre></div>
</div>
<p>Finally, it&#8217;s not allowed to rebind existing words:</p>
<div class="highlight-python"><div class="highlight"><pre>$ dwgrep &#39;let child := 1;&#39;
Error: Can&#39;t rebind a builtin: `child&#39;
</pre></div>
</div>
</div>
<div class="section" id="sub-expression-assertions">
<h2>Sub-expression assertions (<tt class="docutils literal"><span class="pre">?()</span></tt>, <tt class="docutils literal"><span class="pre">!()</span></tt>)<a class="headerlink" href="#sub-expression-assertions" title="Permalink to this headline">¶</a></h2>
<p>Form:</p>
<div class="highlight-python"><div class="highlight"><pre>“?(” EXPR₁ “)”
“!(” EXPR₁ “)”
</pre></div>
</div>
<p>The form <tt class="docutils literal"><span class="pre">?(...)</span></tt> sends an input stack to <em>EXPR₁</em>, which is then
evaluated in sub-expression context.  If it yields anything, the
overall assertion succeeds and yields the original stack.  The form
<tt class="docutils literal"><span class="pre">!(...)</span></tt> has the inverse semantics: it succeeds when <em>EXPR₁</em> yields
nothing.</p>
<p>The behavior of these two forms is equivalent to the following:</p>
<div class="highlight-python"><div class="highlight"><pre>([ EXPR₁ ] != [])       # ?( EXPR₁ )
([ EXPR₁ ] == [])       # !( EXPR₁ )
</pre></div>
</div>
<p>For example, to select leaf DIE&#8217;s of a Dwarf graph:</p>
<div class="highlight-python"><div class="highlight"><pre>!(child)
</pre></div>
</div>
<p>To test whether one of the DIE&#8217;s contains an empty location
expression:</p>
<div class="highlight-python"><div class="highlight"><pre>entry ?(@AT_location !(elem))
</pre></div>
</div>
</div>
<div class="section" id="conditionals-if-then-else">
<h2>Conditionals (<tt class="docutils literal"><span class="pre">if-then-else</span></tt>)<a class="headerlink" href="#conditionals-if-then-else" title="Permalink to this headline">¶</a></h2>
<p>Form:</p>
<div class="highlight-python"><div class="highlight"><pre>“if” EXPR₀ “then” EXPR₁ “else” EXPR₂
</pre></div>
</div>
<p>Input stack is passed to <em>EXPR₀</em>, which is evaluated in sub-expression
context.  Next a body expression is evaluated, which is either <em>EXPR₁</em>
if <em>EXPR₀</em> yielded anything.  Or, if <em>EXPR₀</em> yielded nothing, <em>EXPR₂</em>
is the body expression.</p>
<p>The input stack is then passed to the body expression, which is
evaluated in plain context.  The overall form then yields anything
that the body expression yields.</p>
<p>Both <em>EXPR₁</em> and <em>EXPR₂</em> shall have the same overall stack effect (the
number of slots pushed minus number of slots popped will be the same
for each branch).</p>
<p>This form could be circumscribed by the following snippet:</p>
<div class="highlight-python"><div class="highlight"><pre>(?(EXPR₀) (EXPR₁), !(EXPR₀) (EXPR₂))
</pre></div>
</div>
<p>As an example, consider the following snippet from a script:</p>
<div class="highlight-python"><div class="highlight"><pre>if ?DW_TAG_formal_parameter then (
  // Of formal parameters we ignore those that are children of
  // subprograms that are themselves declarations.
  ?(parent !DW_TAG_subroutine_type !(@DW_AT_declaration == true))
) else (
  ?DW_TAG_variable
)
</pre></div>
</div>
<p>In particular, note the following surprising example:</p>
<div class="highlight-python"><div class="highlight"><pre>$ dwgrep &#39;if false then &quot;yes&quot; else &quot;no&quot;&#39;        # WARNING!
yes
</pre></div>
</div>
<p>The reason is that <tt class="docutils literal"><span class="pre">false</span></tt> is a named constant, which means the
tested expression always yields a stack: namely a stack with <tt class="docutils literal"><span class="pre">false</span></tt>
on top.  This is how Booleans should be tested in Zwerg:</p>
<div class="highlight-python"><div class="highlight"><pre>if (@AT_declaration == true) then … else …
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Syntax</a><ul>
<li><a class="reference internal" href="#comments">Comments</a></li>
<li><a class="reference internal" href="#empty-expression">Empty expression</a></li>
<li><a class="reference internal" href="#words">Words</a></li>
<li><a class="reference internal" href="#concatenation">Concatenation</a></li>
<li><a class="reference internal" href="#parenthesizing">Parenthesizing</a></li>
<li><a class="reference internal" href="#integer-literals">Integer literals</a></li>
<li><a class="reference internal" href="#named-constants">Named constants</a></li>
<li><a class="reference internal" href="#lexical-scopes-a">Lexical scopes (<tt class="docutils literal"><span class="pre">(|A|…)</span></tt>)</a></li>
<li><a class="reference internal" href="#alt-lists">ALT-lists (<tt class="docutils literal"><span class="pre">,</span></tt>)</a></li>
<li><a class="reference internal" href="#or-lists">OR-lists (<tt class="docutils literal"><span class="pre">||</span></tt>)</a></li>
<li><a class="reference internal" href="#infix-assertions">Infix assertions (<tt class="docutils literal"><span class="pre">==</span></tt>)</a></li>
<li><a class="reference internal" href="#iteration">Iteration (<tt class="docutils literal"><span class="pre">*</span></tt>)</a></li>
<li><a class="reference internal" href="#formatting-strings">Formatting strings</a></li>
<li><a class="reference internal" href="#sequence-capture">Sequence capture (<tt class="docutils literal"><span class="pre">[]</span></tt>)</a></li>
<li><a class="reference internal" href="#capture-with-binding-a">Capture with binding (<tt class="docutils literal"><span class="pre">[|A|…]</span></tt>)</a></li>
<li><a class="reference internal" href="#name-binding-let">Name binding (<tt class="docutils literal"><span class="pre">let</span></tt>)</a></li>
<li><a class="reference internal" href="#sub-expression-assertions">Sub-expression assertions (<tt class="docutils literal"><span class="pre">?()</span></tt>, <tt class="docutils literal"><span class="pre">!()</span></tt>)</a></li>
<li><a class="reference internal" href="#conditionals-if-then-else">Conditionals (<tt class="docutils literal"><span class="pre">if-then-else</span></tt>)</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="examples.html"
                        title="previous chapter">Assorted examples</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="vocabulary-core.html"
                        title="next chapter">Core vocabulary</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/syntax.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="vocabulary-core.html" title="Core vocabulary"
             >next</a> |</li>
        <li class="right" >
          <a href="examples.html" title="Assorted examples"
             >previous</a> |</li>
        <li><a href="index.html">dwgrep 0.2 documentation</a> &raquo;</li>
          <li><a href="fulltoc.html" >Table of contents</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, 2015, Petr Machata.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>