-*-org-*-
* Introduction

  Dwgrep is a tool and an associated language for querying Dwarf
  (debuginfo) graphs.  If you want to find out more about Dwarf, you
  can check out the following links.  But you can also pretend that
  Dwarf is like XML, except nodes are called DIE's.  That, and
  perusing the output of eu-readelf -winfo, should be enough to get
  you started.

    http://www.dwarfstd.org/doc/Debugging%20using%20DWARF.pdf
    http://dwarfstd.org/Download.php

  You can think of dwgrep expressions as instructions describing a
  path through a graph, with assertions about the type of nodes along
  the way: that a node is of given type, that it has a given
  attribute, etc.  There are also means of expressing sub-conditions,
  i.e. assertions that a given node is acceptable if a separate
  expression matches (or doesn't match) a different path through the
  graph.

  Apart from Dwarf objects (DIE's and Attributes), dwgrep expressions
  can work with integers, strings, and sequences of other objects.

  In particular, a simple expression in dwgrep might look like this:

  : winfo ?DW_TAG_subprogram child ?DW_TAG_formal_parameter @DW_AT_name

  Which (ignoring the initial colon that's part of meta-syntax) says:
  show me values of attribute DW_AT_name of DW_TAG_formal_parameter
  nodes that are children of DW_TAG_subprogram nodes in .debug_info.
  Reading forward, you get list of instructions to a matcher: take
  .debug_info nodes, accept all DW_TAG_subprogram's, look at their
  children, accept those that are DW_TAG_formal_parameter, take value
  of attribute DW_AT_name.

  Another example comes from dwarflint:

  : winfo ?DW_AT_decl_column !DW_AT_decl_line

  ... which looks for DIE's that have DW_AT_decl_column, but don't
  have DW_AT_decl_line--a semantic violation that is worth reporting.


* Computation

  Conceptually, dwgrep expressions form a pipeline of functions.  The
  Dwarf graph under consideration flows through this pipeline,
  modified by each function of the overall expression, and whatever
  comes out of the other end is the result of the query.

  We call what flows through the dwgrep expression a /working set/.
  Initial working set is empty.  Expressions will typically start with
  selecting an appropriate working set--such as "winfo" seen above.

  As the working set is transformed, its elements can be more than
  just DIE's--as mentioned, they can be also integers, strings, etc.

  Each function takes on input an element of the working set, and
  produces zero or more elements on the output.  Note that producing
  several elements is different from producing an element that holds a
  single value of type sequence.  When a function is applied on a
  working set element, the following can happen:

  - that element is removed (if a function doesn't yield anything)
  - the element is changed for another
  - that element is "forked", replaced with several elements

  When dwgrep expression is evaluated, the functions in the expression
  are applied to each element of the working set, and the output is
  collected to form a new working set.  The whole scheme is thus
  reminiscent of shell pipeline, except you have richer variety of
  types instead of lines.

  There is a subtle difference between values and elements: elements
  contain /stacks/ of values.  Functions in the pipeline consume one
  stack on input, and produce zero or more stacks on output.  If
  nothing is produced, that means that the computation stopped making
  sense: some assertion didn't hold, or an attribute was expected that
  was not available.  Such element is removed from the working set.
  On the contrary, a function can produce several stacks, which means
  that several possible paths forward exist.  The values on stack
  provide a context to the result.


* Introduction to the dwgrep language

  In following, examples are generally written as follows:

  : blah blah lorem ipsum stuff

  The initial colon is not part of the example, but an artifact of
  Emacs org-mode.

** winfo — domain selection

   Since the initial working set is empty, it is usually desirable to
   select the domain that the query should be run over.  The entry
   point of the whole Dwarf graph is a .debug_info section, and the
   corresponding selector, winfo, selects all DIE's in the graph.

   XXX How this will handle .debug_types and partial units is unclear
   as of now.

   XXX A selector for ELF symbol table is planned as well, but as of
   now not implemented.

** ?DW_TAG_foo, ?TAG_foo — DIE tag assertion
** EXPR₁ EXPR₂ … — concatenation

   The assertion "?DW_TAG_foo" takes the value at top of stack (TOS).
   If its tag is not DW_TAG_ID, this function yields nothing.
   Otherwise it yields the input stack unchanged.  The functions which
   either yield an unmodified input or nothing at all are called
   assertions, and are very common in dwgrep expressions.

   You can write ?DW_TAG_foo also as ?TAG_foo, they do the same thing.
   In the following, that's how we will refer to this assertion.

   In dwgrep, function pipelines are formed by simply placing
   functions next to each other.  The stacks that the left function
   produces becomes an input of the right function.

   For example, to list all subprograms, one would use the following
   expression:

   : winfo ?TAG_subprogram

** ?DW_AT_foo, !DW_AT_foo — attribute presence/absence assertion

   "?DW_AT_foo" holds if the value on TOS is a DIE with an attribute
   DW_AT_foo, or if it is an attribute with the name DW_AT_foo.  As
   with tags (and any Dwarf-related assertions at all), you can
   shorten this to ?AT_foo.

   !DW_AT_foo similarly holds if the value on TOS is a DIE that does
   NOT have an attribute DW_AT_foo, or if it's an attribute whose name
   is NOT DW_AT_foo.

   For assertions, concatenation happens to work as a logical and, so
   for example, this is how we can get a list of all subprograms that
   have a declaration attribute:

   : winfo ?TAG_subprogram ?AT_declaration

   Similarly, to get subprograms that do not have declaration
   attribute, we say:

   : winfo ?TAG_subprogram !AT_declaration

** child — child traversal

   This function drops the DIE at TOS, and produces a set of stacks,
   each with one child pushed to TOS.  If applied on a childless DIE,
   it produces nothing, and such computations are thus dropped.  To
   get at the formal arguments of the subprograms from the previous
   example, one might say:

   : winfo ?TAG_subprogram !AT_declaration child

   If we want to make sure these children are actually formal
   parameters:

   : winfo ?TAG_subprogram !AT_declaration child ?TAG_formal_parameter

** @DW_AT_foo — value of attribute DW_AT_foo

   This is the first example of a function that can produce something
   else than Dwarf DIE's.  This will replace the DIE at TOS with a
   value of the attribute of that DIE.  E.g. we could obtain names of
   the formal parameters selected above:

   : winfo ?TAG_subprogram !AT_declaration child ?TAG_formal_parameter @AT_name

   The results would be strings with names of all formal parameters in
   the program.  That's not very useful, as that just lists a bunch of
   names.

   But there's another use of this same feature: for attributes with
   reference form, we get the effect of traversing over the edge
   rooted at given attribute.  For example, we could get types of
   formal parameters thus:

   : winfo ?TAG_subprogram !AT_declaration child ?TAG_formal_parameter @AT_type

   ... which is a bit more useful.  We might use this to discover
   whether some formal parameters have structure types, and would
   therefore incur a potentially expensive copy when the subprogram is
   invoked:

   : winfo ?TAG_subprogram !AT_declaration
   : child ?TAG_formal_parameter @AT_type ?TAG_structure_type

   So that will let us know whether there are any offenders like that.
   That's closer to being interesting, but not quite what we need
   either.  We would like to know about the subprograms themselves,
   that have this property!  Hence:

** ?(EXPR), !(EXPR) — Sub-expressions assertions

   Some dwgrep expressions are evaluated in what we call a
   sub-expression context.  What happens in sub-expression context,
   stays there--the stack effects of sub-expression computation never
   leak back to working set.

   ?(EXPR) expression is one such case.  It asserts that EXPR produces
   at least one element.  We can use it to get to DIE's that have
   arguments that are structures:

   : winfo ?TAG_subprogram !AT_declaration
   : ?(child ?TAG_formal_parameter @AT_type ?TAG_structure_type)

   This asks whether, after going to types of children that are formal
   parameters, we get a structure.  Because the initial two assertions
   have no stack effects anyway, we might say the same thing thus:

   : winfo ?(?TAG_subprogram !AT_declaration
   :         child ?TAG_formal_parameter @AT_type ?TAG_structure_type)

   The other sub-expression assertion, !(), holds if EXPR produces no
   values at all.  We don't need that, but we could use it to reword
   the query thus:

   : winfo ?TAG_subprogram !(?AT_declaration)
   : ?(child ?TAG_formal_parameter @AT_type ?TAG_structure_type)

   If a DIE is a pure declaration, the expression ?AT_declaration
   yields unchanged incoming stack.  But !() only holds for
   expressions that yield nothing at all, thus such DIE's are
   rejected.  More interesting uses of this feature include for
   example selecting child-less DIE's:

   : !(child)

** EXPR == EXPR, EXPR != EXPR — comparisons

   But actually mere ?AT_declaration doesn't tell us whether a DIE is
   a pure declaration.  We can probably safely assume that when a
   compiler produces that attribute, it will have a value of true (and
   a form of DW_FORM_flag_present), so most of the time
   ?AT_declaration (and !AT_declaration) is all you need to write.
   But if we are paranoid, or have grounds for suspicion this is not
   so, we need to actually look at DW_AT_declaration's value.  So
   instead of ?AT_declaration, we should be writing this:

   : (@AT_declaration == true)

   This intuitively-looking construct actually deserves a closer
   attention.  Comparison operators are always evaluated in
   sub-expression context.  The mode of operation is that each side is
   evaluated separately with the same incoming stack.  Then if the
   comparison holds for any pair of produced values, the overall
   assertion holds.  dwgrep has a full suite of these operators--!=,
   <, <=, etc.

   Importantly, comparisons are assertions.  If they hold, they
   produce unchanged incoming stack, otherwise they produce nothing at
   all.  Thus expressions such as ((A > B) == (C > D)) don't mean what
   they seem to.  This one for example is just ((A > B) (C > D))--i.e.
   two independent conditions.  But e.g. ((A > B) != (C > D)), if the
   two >'s hold, reduces to (!=) (inequality of two nops), which
   simply never holds.

   Precedence of comparison operators is lower than that of
   concatenation, so you can write a couple words on each side of the
   operator.  For example, to look for DIE's where one of the location
   expression opcodes is DW_OP_addr, you could say:

   : winfo (@AT_location child label == DW_OP_addr)

   Due to this precedence setting, comparisons are typically enclosed
   in parens (as in the example), so that they don't force too much of
   your computation into sub-expression context.  The precedence is
   however above "," and "||" that are introduced further, so those
   need to be parenthesized further if they should be a comparison
   operand.

   Back to the problem at hand--besides DW_TAG_structure_type, we care
   about DW_TAG_class_type as well!  We can express "and" easily
   simply by juxtaposing the assertions, but we would like a way of
   expressing "or" as well.

** EXPR, EXPR — alternative paths
** EXPR || EXPR — C-style fallback

   The former expression evaluates all constituent EXPR's with the
   same input, and then yields all values that each EXPR yields.  If
   the expressions are assertions, this happens to behave exactly like
   a logical or.  So:

   : winfo ?TAG_subprogram !AT_declaration
   : ?(child ?TAG_formal_parameter @AT_type
   :   (?TAG_structure_type, ?TAG_class_type))

   But the applicability is wider.  Since the semantics are
   essentially those of a fork, one can for example ask whether an
   attribute has one of a number of values:

   : (@AT_name == ("foo", "bar"))

   ... which is the same as:

   : (@AT_name == "foo", @AT_name == "bar")

   The || operator works differently.  It evaluates one expression
   after another, as long as those expressions don't yield anything.
   It thus yields whatever the first expression that actually yields
   anything yields.  It therefore operates in a manner similar to the
   operator || in C language.  The typical use would be in fallbacks.
   For example if we prefer DW_AT_MIPS_linkage_name to DW_AT_name, but
   can make do with the latter, that would be encoded as follows:

   : winfo (@AT_MIPS_linkage_name || @AT_name)

   For selecting structures and classes, we can use either of these
   tools interchangeably.

   So this is fine, but it still shows only functions that take
   structure (or class) arguments directly.  But what if they take a
   const argument?  Or if they take a typedef that evaluates to a
   structure?  For these cases we need to keep peeling the fluff until
   we get to the interesting DIE's.  Enter iterators:

** EXPR*, EXPR+, EXPR? — expression iteration

   - EXPR* leaves the working set unchanged, then adds to that the
     result of one application of EXPR, then of another, etc.  It
     works similarly to * in regular expressions.
   - EXPR+ is exactly like EXPR EXPR*.
   - EXPR? is the same as (, EXPR) — it /may/ apply once

   We can use this tool to remove const_type, volatile_type and
   typedef layers from our potential structure:

   : winfo ?TAG_subprogram !AT_declaration
   : ?(child ?TAG_formal_parameter
   :   @AT_type ((?TAG_const_type, ?TAG_volatile_type, ?TAG_typedef) @AT_type)*
   :   (?TAG_structure_type, ?TAG_class_type))

   Next on, we would like to write a message:

** Literals, Strings, Formatting

   dwgrep understands roughly C-like string literals, using \ as an
   escape character.  Hello world program looks like this in dwgrep:

   : "Hello world!"

   This is an example of a string literal.  Literals in dwgrep add
   themselves to the stack.  There are many types of literals in
   dwgrep--apart from strings and usual numeric literals, dwgrep knows
   about all the named Dwarf constants--e.g. DW_AT_name,
   DW_TAG_array_type, DW_FORM_flag, etc. are all valid dwgrep forms.

   Like C printf, string literals in dwgrep allow formatting
   directives.  To write a nice error message for our running example,
   we could do for example:

   : winfo ?TAG_subprogram !AT_declaration
   : ?(child ?TAG_formal_parameter
   :   @AT_type ((?TAG_const_type, ?TAG_volatile_type, ?TAG_typedef) @AT_type)*
   :   (?TAG_structure_type, ?TAG_class_type))
   : "%s: one of the parameters has non-trivial type."

   When dwgrep sees a string with formatting directives, it converts
   it into a function.  That function pops one parameter for each %s,
   interpolates them all, and then pushes the result to stack.
   Consequently, to convert anything to a string in dwgrep, you would
   just say:

   : "%s"

   The output that our running example above gives would be:

   :  [6c] subprogram: one of the parameters has non-trivial type.

   We would like to improve on that a bit.  We'd like to mention which
   parameter it is, and we'd like to tell the user the name of the
   function, not just a DIE offset.  We'll address both.

** let X := EXPR; — name binding

   Often you need to refer back to a value that was computed earlier.
   Since this is a stack machine, one way to do this is to use stack
   shuffling words--dup, swap, rot, over and drop--to move stuff
   around the way you need it.  But keeping track of what is where
   when gets old quickly.  For this reason, dwgrep allows that you
   give value a name.  That removes that value from the stack, and
   introduces a word that, when mentioned, pushes the bound value back
   to stack.

   : let A := 1; A A add	# gives 2
   : let A B := 10 2; A B div 	# gives 5

   Let's use this tool to remember the two elements that we care
   about: the subprogram (S) and its naked structure parameter (P):

   : let S := winfo ?TAG_subprogram !AT_declaration;
   :
   : let P := S child ?TAG_formal_parameter
   :          ?(@AT_type ((?TAG_const_type,
   :                       ?TAG_volatile_type, ?TAG_typedef) @AT_type)*
   :            (?TAG_structure_type, ?TAG_class_type));
   :
   : P S "%s: Parameter %s has non-trivial type."

   Which is not too shabby, but having to keep track of which %s takes
   which value is perhaps not too comfortable.  For that reason,
   dwgrep allows interpolation of expressions in strings.

** %( %) — format string splicing

   In format strings, code between %( and the matching %) is evaluated
   in plain context, after which TOS of the result is popped and
   inserted in place of the %(...%).  %s is then exactly equivalent to
   %(%).

   With this tool, we can make the formatting string quite a bit
   clearer:

   : let S := winfo ?TAG_subprogram !AT_declaration;
   :
   : let P := S child ?TAG_formal_parameter
   :          ?(@AT_type ((?TAG_const_type,
   :                       ?TAG_volatile_type, ?TAG_typedef) @AT_type)*
   :            (?TAG_structure_type, ?TAG_class_type));
   :
   : "%( S %): Parameter %( P %) has non-trivial type."

   But that still gives something like:
   : [6c] subprogram: Parameter [8f] formal_parameter has non-trivial type.

   Ideally we'd mention names and source code corrdinates instead of
   Dwarf offsets and tag names.  With splicing, it's actually quite
   easy:

   : let S := winfo ?TAG_subprogram !AT_declaration;
   :
   : let P := S child ?TAG_formal_parameter
   :          ?(@AT_type ((?TAG_const_type,
   :                       ?TAG_volatile_type, ?TAG_typedef) @AT_type)*
   :            (?TAG_structure_type, ?TAG_class_type));
   :
   : "%( S @AT_decl_file %): %( S @AT_decl_line %): note: in function "\
   : "`%( S @AT_name %)', parameter `%( P @AT_name %)' type is not trivial."

   Note the string contiuation syntax using "\.  If a string ends with
   "\ instead of mere ", the following string literal is merged with
   the current one.

   If we were paranoid, we could guard against missing @AT_decl_file
   and @AT_decl_line thus (quoting just the relevant part of the above
   example):

   : "%( S @AT_decl_file || "???" %): %( S @AT_decl_line || "???" %): "\
   : "note: in function `%( S @AT_name %)', "\
   : "parameter `%( P @AT_name %)' type is not trivial."

   Note how you can use string literals inside %( %) inside formatting
   strings.  Not that it would be a good idea to nest layers and
   layers of strings, but for a quick default like this, there's no
   harm.

   So, that's it.  This was a quick tour through the interesting parts
   of dwgrep language.  In the following sections, all of it will be
   introduced in a semi-formal, but rather terse format.


* Overview of dwgrep language

  This section describes syntactic constructs in dwgrep.  For a
  catalog of words, see further sections.

  - • means implemented
  - · means partially implemented

** •EXPR₁ EXPR₂ — concatenation

    The constituent EXPR's may yield more than one output value.  A
    new working set is formed by gathering all these returned values.
    If you wish to get an actual list of values instead, see below for
    [] operator, which captures the resulting values and wraps them in
    a sequence.

** •EXPR₁ “,” EXPR₂ … — alternation

   The resulting expression yields all the values that EXPR₁ and EXPR₂
   yield.  In practice this can be used as logical or, or to construct
   sequences.

   All constituent EXPR's shall have the same overall stack effect
   (the number of slots pushed - number of slots popped will be the
   same for each branch).

   - For example, to follow through all edges:
     : (child, attribute ?(form "%s" "DW_FORM_ref.*" ?match))

** •EXPR₁ “||” EXPR₂ … — either-or

   EXPR yields all the values of the first expression that yields
   anything.

** •“(” (“|” ID₁ ID₂ … “|”)? EXPR₁ “)”

     Concatenation has a high precedence, so parentheses can be used
     liberally to adjust how an expression should be chopped into
     sub-expression.  For example:

     : foo bar, baz	# these two ...
     : (foo bar), baz	# ... mean the same thing
     : foo (bar, baz)	# this one is different

     A presence of binding block converts the whole form into a
     function that pops as many arguments as there are identifiers in
     the binding block, and binds them to these identifiers such that
     the rightmost one get the value on TOS and then progressively
     lefter ID's get progressively deeper stack values.  The
     expression is then evaluated as usual, except one can use the
     bound names:

     : (|Dw| Dw winfo (name == Dw symtab name))
     : [foo] [bar] (|A B| A [B elem !(== A elem)] add)	# set union

** •EXPR₁ (“==” | “!=” | “<” | “<=” | “>” | “>=”) EXPR₂ — comparisons
    : ?(let .tmp1 := X; let .tmp2 := Y; .tmp1 .tmp2 OP)
    ... where depending on the operator in question, OP is
    respectively ?eq, ?ne, ?lt, ?le, ?gt, and ?ge.

    In plain English, X and Y are both evaluated in separate
    sub-expression contexts.  Their TOS's are gathered and compared
    using a comparison assertion word.

    Certain integer values have enum-like characteristics.  These
    include those produced by "label", "form", those produced by
    access to certain attributes (such as @AT_language), and constants
    (e.g. DW_AT_name, DW_TAG_class_type, etc.).  For these values,
    dwgrep remembers their domain.  If two values are compared such
    that both have a domain assigned, and those domains differ, a
    warning is produced, because that's likely a flaw in the
    expression.

    Examples:
     : A B swap? (drop>) drop    # "max" -- keep the greater number on stack
     : A B swap? (drop<) drop    # "min"

** •EXPR₁ (“=~” | “!~”) EXPR₂ — string matching
    These are comparison operators with words, respectively, ?match
    and !match.

** •EXPR₁ “*” | EXPR₁ “+” | EXPR₁ “?” — iteration

   EXPR₁ shall have a stack effect of +n,-n (number of slots pushed
   equals number of slots popped).

   - Example: explicit for loop
     : 0 (1 add ?(10 ?lt))*

** •“-”?(“0x”|“0o”|“0b”|“0”|“”){digits} — integer literals
    - 0x and 0X are hexadecimal prefixes.  Valid digits are [0-9a-fA-F].
    - 0o, 0O and 0 are octal prefixes.  Valid digits are [0-7].
    - 0b and 0B are binary prefixes.  Valid digits are [0-1].
    - Without prefix, decimal base is assumed.  Valid digits are [0-9].
    - An initial "-" means the number is negative.
    - dwgrep integers can hold any 64-bit signed or unsigned number:
      : 0xffffffffffffffff -0x7fffffffffffffff add	# 0x8000000000000000

** •“r”? “"” (formatting string) “"”
   - %( and %) enclose an EXPR that's evaluated in plain context, and
     whose input is whatever is the input to the string literal
     itself.  TOS is then popped, converted to a string and embedded
     in the string template.

   - %s stands for %( %)
   - %d stands for %( value %)
   - %x stands for %( value hex %)
   - %o stands for %( value oct %)
   - %b stands for %( value bin %)
   - %% stands for a single %

   - The resulting string is pushed to stack after all formatting
     directives are processed one after another.

   - The r"" strings are raw strings.  They work the same as normal
     formatting strings, but escape sequences are left intact in the
     string.

   - String literals can be split, provided that all but the last
     segment end not with a mere quote, but "\.  The following two
     examples produce equivalent programs:
     : "a long string "\ "that continues here"
     : "a long string that continues here"
     Any whitespace (but only whitespace) is allowed between "\ and
     the followig ".

** •“[” (“|” ID₁ ID₂ … “|”)? EXPR₁ “]” — sub-expression capture

   - [EXPR₁] evaluates EXPR₁ in sub-expression context, gathers TOS's
     of what it yields, and pushes a sequence with those elements.

     : [1, 2, 3]        # produces a list with elements 1, 2 and 3
     : [child]          # list of immediate children
     : [child*]         # list of all descendants

   - [] produces an empty list.  It is exactly equivalent to (among
     others):
     : [ 0 == 1 ]

   - [()] is a capture of nop.  It wraps TOS in a list and pushes it.
     : 1 [()]	# gives 1 [1]

   - Sub-expression capture allows a binding block.  A presence of
     such block converts the whole form into a function that pops as
     many arguments as there are identifiers in the binding block, and
     binds them to these identifiers such that the rightmost one get
     the value on TOS and then progressively lefter ID's get
     progressively deeper stack values.  The expression is then
     evaluated as usual, except one can use the bound names:

     : [|A| A child]		# convert DIE on TOS into a list of its children
     : [|A B| A foo B bar]
     : [|A| A]			# wrap TOS in a list

** •“let” ID₁ ID₂ … “:=” EXPR₁ “;” — binding
    - EXPR₁ is evaluated in sub-expression context.  Then values near
      TOS are bound to given identifiers and exported into surrounding
      context.  From that point on, mentioning ID is the same as
      pushing the value to TOS.

    - Ordering of ID's is such that the rightmost is bound to TOS, the
      next one to the left to one below TOS, etc.  E.g.:

      : let A B := 1 2 ;	# A is 1, B is 2

      The mnemonic for this is that the list of variables describes
      stack layout, with TOS being on the right.

    - When a binding is mentioned that references a block, that counts
      as invocation of the referenced block.  In other words, there's
      an implicit "apply" for bindings that reference blocks.
      : let inc := { 1 add };
      : 2 inc	# 3

** •“{” (“|” ID₁ ID₂ … “|”)? EXPR₁ “}” — blocks

    - {EXPR₁} -- A block syntax.  A value representing an expression
      EXPR₁ is pushed to TOS.  The enclosed expression can later be
      evaluated using an operator "apply".  Application causes EXPR₁
      to be evaluated in plain context.  Thus:
      : {add} 1 2 rot apply	# Leaves 3 on stack.
      : {1 add} 2 swap apply	# Likewise.

    - {|ID₁ ID₂ …| EXPR₁} -- A variant of block syntaxt with an
      identifier block.  When applied, pops TOS and binds it to the
      rightmost identifier, and then proceeds doing the same with
      other identifiers in right to left direction.

      : {|A B| A B add A B sub mul} 3 1 rot apply	# 8

    - When a block is applied, this introduces a new activation record
      (dynamic scope) inside the current scope.  Any let forms bind
      symbols in this new scope.  Upon creation, block literals copy
      values of referenced variables into their scope, so they work as
      closures:

      : let adder := {|x| {|y| x y add}};
      : 3 adder 2 swap apply	# 5

      : let map := {|L f| [L elem f]};
      : [1, 2, 3] {1 add} map	# [2, 3, 4]

    - Because blocks copy surrounding context instead of referencing
      it, all referenced bindings need to be defined at the point of
      block creation.  That precludes a simple way of writing
      recursive functions:

      : # This doesn't work:
      : let fact := {|N| if (N < 2) then 1 else (N 1 sub fact N mul)};

      Here "fact" is referenced inside the block, but at that point,
      it has not yet been defined, and such expression is thus
      erroneous.  It is possible to express recursion, even mutual
      recursion:

      : let f1 := {|N f1 f2|
      :    if (N < 100) then (
      :        N sub 1
      :        {f1} {f2} f2 apply	# recurse to f2
      :    ) else (N)
      : };
      :
      : let f2 := {|N f1 f2|
      :     if (N > 0) then (N mul: 2) else (N)
      :     {f1} {f2} f1 apply		# recurse to f1
      : };
      :
      : 5 {{f1}} {{f2}} f1	# 194

      ... but that is of course ridiculous.  The hope is that
      recursion is rarely useful in a language like this, which is
      meant for querying, not writing algorithms.  Should there be
      serious need for this sort of thing, this functionality would be
      introduced.

    - Example: stack shuffling operators.  (N.B.: this example uses
      underscores to distinguish from the corresponding built-in
      words.   Redefining built-ins is not allowed.)
      : let drop_ := {|a|};
      : let dup_ := {|a| a a};
      : let swap_ := {|a b| b a};
      : let rot_ := {|a b c| b c a};
      : let over_ := {|a b| a b a};

** •“?(” EXPR₁ “)” | “!(” EXPR₁ “)” — sub-expression assertions

    ?(EXPR₁) is an assertion that holds if EXPR₁ yields at least once.
    !(EXPR₁) holds when it doesn't yield at all.

    - ?( EXPR₁ ) is exactly equivalent to:
      : ([ EXPR₁ ] != [])
    - !( EXPR₁ ) is exactly equivalent to:
      : ([ EXPR₁ ] == [])

    - Examples:
      : !(child)       # keep leaf DIE's only

** •“if” EXPR₀ “then” EXPR₁ “else” EXPR₂ — conditionals

   - EXPR₀ is evaluated in sub-expression context.  If it yields
     anything, EXPR₁ is evaluated in plain context.  Otherwise EXPR₂
     is evaluated in plain context.

**  “while” EXPR₀ “do” EXPR₁ | “do” EXPR₁ “while” EXPR₀

   - The "while..do" loop checks whether EXPR₀ yields anything.  If
     yes, it evaluates EXPR₁ and repeats; otherwise it doesn't do
     anything.

     "do..while" works similarly, but it first evaluates EXPR₁ and
     then tests whether EXPR₀ yields anything.

   - EXPR₀ is evaluated in sub-expression context.
   - EXPR₁ shall have neutral stack effect.

** •“\dbg” — debug print

   Doesn't alter the stack in any way, but as a side effect prints
   some information about the computation in whose context it
   appeared.

** •colon infix syntax
    - When a word is followed by a colon, the following statement is
      executed before that word.  That can be used for writing the
      operators, where it makes sense, in infix form.  For example:
      : 10 add: 1	# equivalent to (10 1 add)
      : [10 range] sort: {a | if (a mod: 2 == 0) then 0 else 1}

** •comments
    - Comments start with either # or // and continue until the end of
      the line; or they start with /* and continue until */.  Nesting
      comments is not allowed.


* Fundamental words
** •dup, over, swap, rot, drop — stack shuffling
   These words reorder elements on stack according to the following
   schemes:

   |------+---------+-----------|
   | op   | before  | after     |
   |------+---------+-----------|
   | dup  | A B C D | A B C D D |
   | over | A B C D | A B C D C |
   | swap | A B C D | A B D C   |
   | rot  | A B C D | A C D B   |
   | drop | A B C D | A B C     |
   |------+---------+-----------|

   Realistically, most of what end users should write will be an
   occasional dup, possibly a swap.  Drop shouldn't be needed (that's
   what sub-expressions are for), and the deep stack manipulation
   should be unnecessary as well.  But they are present for
   completeness' sake.

** •type :: ?() -> ?T_CONST
   This produces a constant according to the type of value on TOS
   (such as T_CONST, T_DIE, T_STR, etc.).

** •pos :: ?() -> ?T_CONST
    Each function numbers elements that it produces, and stores number
    of each element along with the element.  That number can be
    recalled by saying "pos".

    If you wish to know the number of values produced, you have to
    count them by hand:
    : [ child ] let L := length; elem

** •?eq, ?ne, ?gt, ?ge, ?lt, ?le :: ?() ?()
    These are low-level assertions that can be used instead of ==, !=,
    etc.

    Two elements are inspected: TOS and one below that (B and A,
    respectively).  The assertion holds if A op B is true.  Comparing
    values of different types is not defined, and such assertions fail
    as well.

    Note that there is both !eq and ?ne, !lt and ?ge, etc.  These are
    mostly for symmetry--the assertions need "?" to denote that they
    are assertions, so why not have "!" forms as well.  For !eq it
    even makes a good sense.


* Words for intrinsic types
** ·T_CONST
*** •value :: ?T_CONST -> ?T_CONST
     Returns underlying value of the constant, with plain domain.
     : DW_FORM_flag value	# gives 12

*** •add, sub, mul, div, mod :: ?T_CONST ?T_CONST -> ?T_CONST
     Two elements are popped: A and B, with B the original TOS, and "A
     op B" is pushed again.

     division and modulo by zero produce an error message and abort
     current computation.

*** •hex, oct, bin :: ?T_CONST -> ?T_CONST
     These yield incoming stack, except the domain of constant on TOS
     is changed.
     : 64 hex		# gives 0x40
     : DW_AT_name hex	# gives 0x3

     The value remains a constant, only the way it's displayed
     changes.  You can use "%s" to convert it to a string, in which
     case it's rendered with the newly-selected domain.
     : DW_AT_name "%s"		# gives "DW_AT_name"
     : DW_AT_name hex "%s"	# gives "0x3"

***  int32_t, uint32_t, int64_t, uint64_t :: ?T_CONST -> ?T_CONST
     The idea behind uint32_t et.al. is that a two-complement
     representation of a given constant is taken, if necessary, it's
     sign-extended, and then a 32-bit or 64-bit slice of that is
     taken, and that is reinterpreted as either a signed or unsigned
     value:

     : -1 hex			# gives -0x1
     : -1 uint32_t hex		# gives 0xffffffff
     : -1 uint64_t hex		# gives 0xffffffffffffffff
     : 0xffffffff int32_t	# gives -1
     : 0xffffffffff int32_t	# gives -1 as well
     : 0xffffffff int64_t	# gives 0xffffffff

     Maybe what we want instead is "32 uint", "64 int" etc., such that
     bit length is configurable.

***  intptr_t, uintptr_t :: ?T_CONST -> ?T_CONST
     {,u}intptr_t then expands to either of {,u}int{64,32}_t depending
     on address size of CU.  XXX how to get to that size?  What
     should, say, "17 uintptr_t" do?  There's no CU in sight...

** ·T_SEQ
*** •add :: ?T_SEQ ?T_SEQ -> ?T_SEQ
     Concatenates two sequences.

*** •elem :: ?T_SEQ ->* ?()
     Pops a list, and for each element yield a stack with that element
     pushed on top.

     To zip contents of two top lists near TOS, do:
     : ->A B; A elem B elem (pos == swap pos)

     This takes two lists from the stack, and produces stacks that
     have those lists replaced with individual elements that
     correspond to each other.  For example:
     : A B [C₁, C₂, C₃] [D₁, D₂, D₃]

     ... would be replaced with three stacks:
     : (A B C₁ D₁, A B C₂ D₂, A B C₃ D₃)

*** •relem :: ?T_SEQ ->* ?()
     This is like elem, but yields elements in reverse order.

*** •length :: ?T_SEQ -> ?T_CONST
     Yields length of sequence on TOS.

*** •?empty :: ?T_SEQ
     Asserts whether a sequence on TOS is empty.

*** •?find :: ?T_SEQ ?T_SEQ
    (A B find) asserts that the sequence A contains sub-sequence B
    (e.g. [hay stack] ?([needle] ?find)).

    To determine whether a sequence contains a particular element, you
    would use the following construct:
    : [that sequence] (elem == something)

    E.g.:
    : [child @AT_name] ?(elem == "foo")
    : [child] ?(elem @AT_name == "foo")

    To pick only those elements that match, you could do the
    following:
    : [child] [|L| L elem ?(@AT_name ?"foo")]

    The above is suitable for a function that takes a list on input
    and wants to filter it.  It is of course preferable to write this
    sort of thing directly, if possible:
    : [child ?(@AT_name ?"foo")]

***  at :: ?T_SEQ ?T_CONST -> ?()

     One can access a particular element by enumerating the array with
     elem or relem, and then do assertions on pos:

     : [some seq] elem (pos == 0)	# [0]
     : [some seq] relem (pos == 0)	# [-1]
     : [some seq] elem (pos != 0)	# [1:]
     : [some seq] elem (pos >= 3 && pos < 6)	# [3:6]
     : [some seq] relem (pos > 0)	# [:-1]

     I don't suppose array operations will be widely used, so maybe
     this is just fine.  Most of the time, instead of producing a
     sequence, you would just assert position on the producing
     expression directly.

     If it turns out to be useful, we can adopt an "at" word, which
     would follow Python indexing conventions:

     : [some seq] at: 0		# elem (pos == 0)
     : [some seq] at: -1	# relem (pos == 0)

     We could also have:
     -- slice :: ?T_SEQ ?T_CONST ?T_CONST -> ?()
     -- slice :: ?T_SEQ ?T_CONST -> ?()

     : [some seq] 1 slice	# elem (pos != 0)
     : [some seq] 3 6 slice	# elem (pos >= 3 && pos <= 5)
     : [some seq] 0 -1 slice	# relem (pos > 0)

     We would need both versions because there's no placeholder like
     None in Python, where [1:] means [1:None] and None is treated
     like one past last element.  0 can't be used in that capacity, as
     then it wouldn't be clear whether (0 0 slice) needs to yield
     nothing or everything.

***  fold :: ?T_SEQ ?() ?T_CLOSURE ->* ?()
     - This takes care of all sorts of summing and joining list
       elements.  E.g. "join" is:
       : [the sequence] "" {"%s" add} fold
       "sum" is:
       : [the sequence] 0 {add} fold

** ·T_STR
    Many words, applicable to sequences, are applicable to strings as
    well.  The semantics are as if the string was a sequence of all
    the constituent characters (the characters themselves are again of
    type T_STR).  The prototypes are as if T_SEQ was replaced with
    T_STR.

*** •add (as T_SEQ)
*** •elem (as T_SEQ)
*** •relem (as T_SEQ)
*** •length (as T_SEQ)
*** •?empty (as T_SEQ)
*** •?find (as T_SEQ)
*** •?match :: ?T_STR ?T_STR
     This asserts that TOS (which is a string with a regular
     expression) matches the value below TOS.  The whole string has to
     match.  If you want to look for a regular expression inside the
     string, you can say ("haystack" ?(".*needle.*" ?match)).

***  demangle :: ?T_STR -> ?T_STR

** •T_CLOSURE
*** •apply :: T_CLOSURE ->
     The block on TOS is executed.


* Representation of Dwarf graph
** Common words
   Quite a few words are reused to be aplicable to objects of
   different types.  These include label, offset, address, high, low,
   name and value.

** ·Entry points
*** ·dwopen :: ?T_STR -> ?T_DWARF
     - Pops a file name, opens an ELF with that name, and pushes a
       value representing that file to TOS.

     - When files are passed on command line, those are pre-opened and
       pre-pushed by the query driver, and appear as sole value on
       runtime stack:
       : $ dwgrep ./a.out -e 'type'
       : T_DWARF

** ·T_DWARF
*** ·winfo :: ?T_DWARF ->* ?T_DIE
     Yields all DIE's in a .debug_info section.  In produces values of
     type T_DIE.

     XXX How do we handle DW_TAG_partial_unit?

***  symtab :: ?T_DWARF ->* ?T_ELFSYM
     Yields all symbols in .symtab, or minisymtab, or .dynsym.  It
     produces values of type T_ELFSYM.

***  name :: ?T_DWARF -> ?T_STR

** ·T_DIE
*** •label :: ?T_DIE -> ?T_CONST
     Yields DIE tag.

*** •offset :: ?T_DIE -> ?T_CONST
     Like dwarf_dieoffset.

*** ·unit :: ?T_DIE ->* ?T_DIE
     Selects objects belonging to the same logical unit.

     XXX how do we solve logical vs. low-level access to
     DW_TAG_partial_unit?  We could have winfo/wtype/wunit. for
     low-level access and info/unit for interpreted access.

*** •high :: ?T_DIE ->? ?T_CONST
     : attribute ?AT_highpc address

*** •low :: ?T_DIE ->? ?T_CONST
     : @AT_lowpc

*** •address :: ?T_DIE ->* ?T_ADDR_RANGE
     Like dwarf_ranges.

*** •child :: ?T_DIE ->* ?T_DIE
     Yields children of the DIE.

*** •attribute :: ?T_DIE ->* ?T_ATTR
     Yields attributes of the DIE.

*** •parent :: ?T_DIE ->? ?T_DIE
     Yields the parent of the DIE, if there's any.

     XXX DW_TAG_partial_unit

*** •?root, !root :: ?T_DIE
     ?root holds if the DIE is a root node.  Equivalent to !(parent).

     : parent* ?root        # finds a root node of node on TOS

***  next :: ?T_DIE ->? ?T_DIE
     Like dwarf_siblingof, returns next sibling of the DIE.

     : def next {|D| D parent child (pos == D parent child (== D) pos 1 add)}

     The first line is necessary to make sure that pos later refers
     to order in children array, not to e.g. a result of ([XYZ] each).

***  prev :: ?T_DIE ->? ?T_DIE
     The opposite of next.

*** •integrate :: ?T_DIE ->? ?T_DIE
     Equivalent to the following:
     : (@AT_abstract_origin || @AT_specification)

     It is meant to be used as named edge between a DIE and its
     abstract instance(s).  In particular, the following idioms might
     be useful:

     : integrate* ?AT_xyz		# find DIE's with DW_AT_xyz
     : integrate* @AT_xyz		# all AT_xyz's in chain
     : [integrate*]			# the whole integration chain

     : (!AT_xyz integrate)* ?AT_xyz	# find closest DIE with DW_AT_xyz
     : ?(integrate* ?AT_xyz)		# dwarf_hasattr_integrate
     : (!AT_xyz integrate)* attribute ?AT_xyz	# dwarf_attr_integrate
     : (!AT_xyz integrate)* @AT_xyz	# value of integrated DW_AT_xyz

***  integrate :: ?T_DIE ?T_CLOSURE ->* ?()
     Given the above as "integrate1", the behavior of this "integrate"
     can be specified thus:

     : let integrate := {|Op| (!(Op) integrate1)* Op};

     This then can be used as follows:
     : {?AT_xyz} integrate		# find closest DIE with DW_AT_xyz
     : ?({?AT_xyz} integrate)		# dwarf_hasattr_integrate
     : {attribute ?AT_xyz} integrate	# dwarf_attr_integrate
     : {@AT_xyz} integrate		# value of integrated DW_AT_xyz

*** •@AT_decl_file
     Value of this attribute is represented as actual string including
     path.

     (XXX we ignore mtime and size.  Those aren't stored anyway, but
     maybe it would be useful to have them so that one can do this
     sort of querying in the first place--do we have any files where
     this is stored?  Or after it gets to be stored in general, where
     this is _not_ stored?)

***  abbrev :: ?T_DIE -> T_ABBREV
*** •@AT_* :: ?T_DIE ->* ?()
     Syntactic sugar for (attribute ?(label == AT_*) value).

*** •?AT_* :: ?T_DIE
     Holds if DIE has this attribute.

*** •?TAG_* :: ?T_DIE
     Holds if DIE has this tag.

***  ?LANG_* :: ?T_DIE
     Holds if (@AT_language == DW_LANG_*).

***  ?ATE_* :: ?T_DIE
     Holds if @AT_encoding == DW_ATE_*.

*** •flag :: ?T_DIE ?T_CONST ->? (==true || ==false)
     : let flag := {|F|
     :   if !(attribute label == F) then (
     :     false
     :   ) else (
     :     attribute (label == F) flag/T_ATTR
     :   )
     : };

** ·T_ATTR
*** •label :: ?T_ATTR -> ?T_CONST
     Yield an attribute name.

*** •value :: ?T_ATTR ->* ?()
     Yields value(s) of attribute on TOS.

     Some attributes refer to a location expression.  These are
     represented as a number of nodes of type T_LOCLIST_ELEM.
     Children of these nodes are T_LOCLIST_OP, individual operations
     of location expression.

*** •address :: (?T_ATTR (?AT_high_pc, ?AT_low_pc, ?FORM_addr)) -> ?T_CONST
     - For DW_AT_high_pc, DW_AT_entry_pc with constant forms, this
       converts the value to address.

     - For attributes with address form, this is like calling "value".

     - Otherwise it is an error to use this.

*** •form :: ?T_ATTR -> ?T_CONST
     Yield a form of an attribute.

***  next :: ?T_ATTR ->? ?T_ATTR  (XXX is this useful?)
***  prev :: ?T_ATTR ->? ?T_ATTR  (XXX is this useful?)
*** •?AT_* :: ?T_ATTR
     Holds if it is this attribute.

*** •?FORM_* :: ?T_ATTR
     Holds if the attribute has this form.

***  ?LANG_* :: ?T_ATTR
     Holds if (?AT_language value == DW_LANG_*).

***  ?ATE_* :: ?T_ATTR
     Holds if (?AT_encoding value == DW_ATE_*)

*** •flag :: ?T_ATTR ->? (==true || ==false)
     : let flag := { (?FORM_flag, ?FORM_flag_present) value };

**  T_ABBREV
***  label :: ?T_ABBREV -> ?T_CONST
***  offset :: ?T_ABBREV -> ?T_CONST
***  attribute :: ?T_ABBREV ->* T_ABBREV_ATTR
***  @AT_* :: ?T_ABBREV ->? T_CONST
     Yields a form of an attribute.
***  ?AT_* :: ?T_ABBREV
     Holds if abbreviation has this attribute.

**  T_ABBREV_ATTR
***  label :: ?T_ABBREV_ATTR -> ?T_CONST
     Yields attribute name.

***  offset :: ?T_ABBREV_ATTR -> ?T_CONST
     Yields offset of attribute within abbreviation.

***  form :: ?T_ABBREV_ATTR -> ?T_CONST
     Yields attribute form.

***  ?AT_* :: ?T_ABBREV_ATTR
     Holds if it is this attribute.

***  ?FORM_* :: ?T_ABBREV_ATTR
     Holds if the attribute has this form.

**  T_ELFSYM
***  label :: ?T_ELFSYM -> ?T_CONST
     Yields symbol type, such as STT_FUNC.

***  value, address :: ?T_ELFSYM -> ?T_CONST
     Yield symbol value.

***  @name :: ?T_ELFSYM -> ?T_STR
***  @size :: ?T_ELFSYM -> ?T_CONST
***  @bind :: ?T_ELFSYM -> ?T_CONST
***  @visibility :: ?T_ELFSYM -> ?T_CONST
***  @index :: ?T_ELFSYM ->? ?T_CONST
     XXX or maybe @section?

***  symbol :: ?T_CONST ->? T_ELFSYM
     This find a symbol associated with an address on TOS.  The match
     doesn't have to be exact, offset would then be:
     : let A := some addr; A symbol dup address A sub
     :  # now TOS has offset and below TOS is symbol

     XXX some of this is fairly easy to get by cross-matching like
     this:
     : symtab (address == some addr)
     fuzzy matching (getting symbol/offset) would be more involved.

** •T_LOCLIST_ELEM
    XXX possibly a means of evaluating?  (Could we use the in-program
    stack for evaluating the Dwarf expression?)

*** •address :: ?T_LOCLIST_ELEM -> ?T_ADDR_RANGE
     Yields where given location expression applies.

*** •elem :: ?T_LOCLIST_ELEM ->* ?T_LOCLIST_OP
     Yields individual location expression operators.

*** •relem :: ?T_LOCLIST_ELEM ->* ?T_LOCLIST_OP
     Like elem, but yields in opposite direction.

*** •?OP_* :: ?T_LOCLIST_ELEM
     Holds if this location expression contains an operation with this
     opcode.

** •T_LOCLIST_OP
*** •label :: ?T_LOCLIST_OP -> ?T_CONST
     Yields operation opcode (a DW_OP_* constant).

*** •offset :: ?T_LOCLIST_OP -> ?T_CONST
     Yields an offset of this op within the location expression.

*** •value :: ?T_LOCLIST_OP ->* ?()
     Yields operands associated with this location expression
     operation.  Operands have anywhere between zero and two operands
     of various types (some are e.g. T_DIE references).

     For example:

     : [4e] variable
     :      [...]
     :      location (exprloc) [0x0..0xffffffffffffffff, [0:fbreg<-18>]]

     Here we have only one T_LOCLIST_OP, and that has an offset of 0, a
     label of DW_OP_fbreg, and yields one value, -18.

*** •?OP_* :: ?T_LOCLIST_OP
     Holds if this is an operation with this opcode.

** ·T_ADDR_RANGE
    - T_ADDR_RANGE actually behaves pretty much like a sequence of
      integers.  Maybe sequence could have an optimization whereby if
      it contains integers only, it just stores low×high pairs instead
      of listing each value separately.

    - We would still need a way of promoting assertions directly to
      "elem" such that it can do something clever instead of
      enumerating all 64 bits of adress space or some such.

    - XXX Consider promoting this to core (T_RANGE, T_INTERVAL or some
      such).  Address ranges would be intervals whose limits are
      T_CONST with dw_address_dom.

      If this should hold anything else than pairs of constants, it
      would need "length" to have access to the overload dictionary to
      look up "sub" in.

*** •low :: ?T_ADDR_RANGE -> ?T_CONST
*** •high :: ?T_ADDR_RANGE -> ?T_CONST
*** •arange :: ?T_CONST ?T_CONST -> ?T_ADDR_RANGE
*** •length :: ?T_ADDR_RANGE -> ?T_CONST
     (high low sub)

***  overlap :: ?T_ADDR_RANGE ?T_ADDR_RANGE -> ?T_ADDR_RANGE
     Produce a new range with overlap of the two constituents.
*** •?contains :: ?T_ADDR_RANGE ?T_CONST
*** •?contains :: ?T_ADDR_RANGE ?T_ADDR_RANGE
     Whether TOS is contained within below TOS.

*** •?overlaps :: ?T_ADDR_RANGE ?T_ADDR_RANGE
     Whether TOS and below TOS overlap.

*** •?empty :: ?T_ADDR_RANGE
     (low == high)


* Examples

** Josh Stone's nontrivial-parameters script

   : let A := winfo ?TAG_subprogram !AT_declaration
   :          ?(@AT_decl_file ?("^/usr/" ?match) ?("^/usr/src/debug" !match));
   :
   : let B := A child ?TAG_formal_parameter
   :          ?(@AT_type ((?TAG_const_type, ?TAG_volatile_type, ?TAG_typedef)
   :            @AT_type)* (?TAG_structure_type, ?TAG_class_type));
   :
   : "%( A @AT_decl_file %): %( A @AT_decl_line %): note: in function "\
   : "`%( A @AT_name %)', parameter `%( B @AT_name %)' type is not trivial"

** check_die_decl_call:
   : (winfo ?AT_decl_column !AT_decl_line "%s has decl_column, but NOT decl_line"
   : , etc.)

** check_die_line_info:
   : let A := winfo (?TAG_subprogram, ?TAG_inline_subroutine, ?TAG_entry_point,
   :                ?TAG_lexical_block, ?TAG_label, ?TAG_with_stmt,
   :                ?TAG_try_block, ?TAG_catch_block);
   : let B := A (@AT_entry_pc, @AT_low_pc, @AT_ranges);
   : let C := A parent* ?root !(@AT_stmt_list address == B);
   : "Address %( B %) referenced from %( C %) not found in line table."

** contains DW_OP_fbreg && ! @frame_base
   : !AT_frame_base (@AT_location label == DW_OP_fbreg)

** uses register based operators

   : winfo ?(@AT_location elem label
   :         (== DW_OP_bregx || (>= DW_OP_reg0) (<= DW_OP_regx)))

   : winfo ?(@AT_location elem label "%s" "_b?reg" ?find)

** whether it uses a deref operator

   : ?(@AT_location label (?OP_deref, ?OP_xderef, ?OP_deref_size,
   :                       ?OP_xderef_size, ?OP_GNU_deref_type))

   : ?(@AT_location label "%s" "deref" ?find)

** contains DW_OP_call_frame_cfa && $@low_pc == 0

   : winfo (@AT_low_pc == 0) ?(@AT_frame_base ?OP_call_frame_cfa)

** is an empty location expression

   : winfo ?AT_location !(@AT_location)

** location expression ends with implicit_value or stack_value

   : winfo ?([@AT_location] relem (pos == 0) label
   : (?DW_OP_implicit_value, ?DW_OP_stack_value))

** types inconsistent between instance and specification
   - http://gcc.gnu.org/bugzilla/show_bug.cgi?id=43053

     : let A := winfo ?TAG_subprogram;
     : let B := A child ?TAG_formal_parameter;
     : let C := A @AT_specification child ?TAG_formal_parameter;
     : (B pos == C pos) (B @AT_type != C @AT_type) A

** duplicat DW_TAG_const_type
   - http://gcc.gnu.org/bugzilla/show_bug.cgi?id=56740

     : let ?cvr_type := {?TAG_const_type,?TAG_volatile_type,?TAG_restrict_type};
     : let A := winfo ?cvr_type ;
     : let B := A unit ?(> A) ?cvr_type ;
     : (A tag == B tag) (A @AT_type == B @AT_type) A B

** find any attribute with value "blah"
   : attribute (value == "blah")

** check_duplicate_DW_tag_variable.cc
   Check for two full DW_TAG_variable DIEs with the same DW_AT_name
   value.

   : winfo ?TAG_variable (@AT_name == next+ ?TAG_variable @AT_name)

   - XXX
     : winfo dup next+ <?TAG_variable @AT_name>?eq

** check_linkage_external_die.cc

     : (|Dw|
     :  let GetSym := {|X| Dw symtab (?STT_OBJECT, ?STT_FUNC)
     :                     (@name == X @AT_linkage_name)};
     :  Dw winfo ?AT_linkage_name
     :  if !(GetSym) then (
     :      !AT_declaration !AT_const_value
     :      (!structure_type !enumeration_type !union_type, ?AT_name)
     :      "%s has linkage_name attribute that's not in symtab, "\
     :      "but is not marked as declaration"
     :  ) else if (GetSym ?STB_LOCAL) then (
     :      !AT_declaration ?AT_external
     :      "%s has linkage_name attribute, "\
     :      "but the corresponding symbol is local"
     :  ) else (
     :      !AT_external
     :      "%s has linkage_name attribute, but no external attribute"
     :  ))

   This is still 1:10 vs. dwarflint C++ (i.e., say 1:20 if we had to
   explore the DIE tree by hand), but fairly involved.

   The interpreter would need to notice the ?symbol nodes are used as
   a sort of global variable for cross-referencing, otherwise this
   would lead to an ugly combinatorial explosion of states.  Noticing
   that we look at the bottom slot and cross-reference @AT_name with
   @AT_linkage_name should be possible.

   An alternative start would be something like:
   : let Dw := "$1" dwopen;

** CU A imports two PU's B and C, and both import the same third PU

   : let imports := {parent* ?root child ?TAG_imported_unit @AT_import};
   :
   : let U := winfo ?root ;
   : let A := U child ?TAG_imported_unit @AT_import ;
   : let B := U child ?TAG_imported_unit @AT_import (> A) ;
   : A imports B imports (== swap)
   : "PU %(offset%) is imported by PU's %(A offset%) and %(B offset%), "\
   : "which are both imported by %(U offset%)."

** typedef resolution
   - dsmith asked for a way to get typedef "resolution" from DWARF
     (for use with the syscall types in the kernel). Which was timely
     since I was just thinking about having some "roundtripping" tests
     for GCC/elfutils DWARF types. So hacked up a dwfltypedef that
     prints all (C) typedefs found:

     $ ./dwfltypedef -e ./dwfltypedef
     [2d] typedef size_t long unsigned int (unsigned, 8 bytes);
     [70] typedef __off_t long int (signed, 8 bytes);
     [7b] typedef __off64_t long int (signed, 8 bytes);
     [...]

     : let T := winfo ?TAG_typedef ;
     : let U := T @AT_type (?TAG_typedef @AT_type)* !TAG_typedef ;
     : "[%(T offset%)] typedef %(T @AT_name%) %(U @AT_name%) "\
     : "(%( U @AT_encoding || "???" %), %( U @AT_byte_size || "???" %) bytes)"

     [0x57] typedef __int32_t int (DW_ATE_signed, 4 bytes)
     [0x70] typedef __off_t long int (DW_ATE_signed, 8 bytes)
     [0x7b] typedef __off64_t long int (DW_ATE_signed, 8 bytes)
     [0x9c] typedef __intptr_t long int (DW_ATE_signed, 8 bytes)
     [0xa7] typedef size_t long unsigned int (DW_ATE_unsigned, 8 bytes)
     [...]

** nested identifier names
   : (@AT_name == "a") child (@AT_name == "b") child (@AT_name == "c")
